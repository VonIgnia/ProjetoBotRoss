#PT_BR bibliotecas para processamento de imagem
#US_EN libraries for image processing

import cv2
import matplotlib.pyplot as plt
import numpy as np
from pykuwahara import kuwahara
from math import *

#PT_BR arquivo criado pelos desenvolvedores para armazenar as funções e deixar o código mais limpo
#US_EN developer created file in order to store the functions and make a cleaner code here
import Functions

#PT_BR bibliotecas para comunicação com o UR5
#US_EN libraries for UR5 communication
import socket
import time
import threading

# SimplifyImageColors "scans" an image and convert every pixel color to the closest color in HSV from the availabel colors list
def Simplify_Image_Colors(img_in, available_colors_list, kH = 1, kS = 1 , kV = 1):
    #available_color_list is a list composed of a number of lists with 3 elements(Hue, Saturation, Value) 
    #kH, kS and kV are weight factor attributed to importance of Hue, Saturation nd Value respectively
    hsv_resized_image = cv2.cvtColor(img_in, cv2.COLOR_BGR2HSV)
    [H,S,V] = cv2.split(hsv_resized_image)
    (height,width) = H.shape

    #converts "normal" parameters of HSV to opencv2 parameters of HSV (check opencv documentation)
    for color in available_colors_list:
        color[0] = int(np.clip((color[0])/2,0,255))
        color[1] = int(np.clip((color[1]*255)/100,0,255))
        color[2] = int(np.clip((color[2]*255)/100,0,255))

    H_out = np.zeros((height,width), dtype = "uint8")
    S_out = np.zeros((height,width), dtype = "uint8")
    V_out = np.zeros((height,width), dtype = "uint8")

    for i in range(height-1):
        for j in range(width-1):
            #icv refers to image color vector and corresponds to the HSV vector from the pixel [i,j]
            icv = [H[i,j],S[i,j],V[i,j]]
            euclidian_distance_list = []
            #avc refers to available color vector and corresponds to the HSV vector from the availabel colors list
            
            #calculate the distance beetwen the availabel color and the pixel color for every available color
            for avc in available_colors_list:
                dist_euclidiana = sqrt(((avc[0]-icv[0])**2)*kH + ((avc[1]-icv[1])**2)*kS + ((avc[2]-icv[2])**2)*kV)
                euclidian_distance_list.append(dist_euclidiana)
            
            #the minimum distance indicates what availabel color is the closest to the pixel color 
            min_dist_index = np.argmin(euclidian_distance_list)
            H_out[i,j] = available_colors_list[min_dist_index][0]
            S_out[i,j] = available_colors_list[min_dist_index][1]
            V_out[i,j] = available_colors_list[min_dist_index][2]

    hsv_img_out = cv2.merge((H_out,S_out,V_out))

    return hsv_img_out

#Split colors input is generated by SimplifyImageColors
#It creates an array of binary images, one for each available color
def Split_Colors(img_in, lista_cores_disponiveis):
    (height,width) = (img_in.shape[0], img_in.shape[1])
    
    for color in lista_cores_disponiveis:
        img_out = img_in
        for i in range(height-1):
            for j in range(width-1):
                #print(hsv_img_out[i,j], "o", color)
                if np.all(img_in[i,j] == color):
                    img_out[i,j] = color
                else:
                    img_out[i,j] = [0,0,0]
        img_out = cv2.cvtColor(img_out, cv2.COLOR_HSV2BGR)
        cv2.imshow(str(color), img_out)
        cv2.waitKey(0)
        return img_out

def Generate_contours(img_in):
    # Turn a Grayscale input Image into a binary image
    returns, thresh = cv2.threshold(img_in, 170, 255, cv2.THRESH_BINARY)
    
    # Find contours in the binary image
    contours, hierachy = cv2.findContours(thresh, cv2.RETR_LIST, cv2.CHAIN_APPROX_NONE)
    #drop the last contourn (the frame)
    contours = contours[:-1]
    
    # Draw the contours on a black image
    height, width = img_in.shape
    image = np.zeros((height, width), dtype=np.uint8)
    cv2.drawContours(image, contours, -1, (255, 255, 255), 2)

    # Initialize the list of contour points with added z-coordinate
    Contour_Points = []

    for contour in contours:
        # Add the starting z-coordinate for each contour
        #Contour[0][0][0] being position along x-axis and Contour[0][0][1] being position along y-axis
        Contour_Points.append([contour[0][0][0], contour[0][0][1], 20])

        for point in contour:
            # Add the x, y, and z coordinates to the list
           Contour_Points.append([point[0][0], point[0][1], 0])

        # Add the ending z-coordinate for each contour
        Contour_Points.append([contour[-1][0][0], contour[-1][0][1], 20])

    return Contour_Points, image

def Generate_fillings(img_in):
    img_out = img_in
    return img_out


def Gera_preenchimento_Vf(img_in):

    _, imagem_binarizada = cv2.threshold(img_in, 170, 255, cv2.THRESH_BINARY_INV)

    height, width = imagem_binarizada.shape[:2]
    line_spacing = 2

    # create a frame
    image = np.zeros(imagem_binarizada.shape, dtype=np.uint8)

    # Draw horizontal lines on the binary image
    for y in range(0, height, line_spacing):
        for x in range(0, width):
            image[y,x] = imagem_binarizada[y,x]

    imagem_binarizada = image

    # Find contours
    contours, hierarchy = cv2.findContours(imagem_binarizada, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)

    i=0
    dict_filling_points = {}
    for contour in contours:
        i+=1
        filling_points = []
        
        x,y,w,h = cv2.boundingRect(contour)
        filling_points.append([x,y])
        filling_points.append([x+w,y])
        
        cv2.line(imagem_binarizada, (x,y), (x+w,y), (255,255,255), 1) 

        dict_filling_points["Preenchimento{}".format(i)] = filling_points

    Prototipo_lista_preenchimentos = []

    i_atual = 0 #flag para checar se mudou de Contorno{numero do contorno} para Contorno{numero do contorno+1}
    
    for i in dict_filling_points: #para cada elemento(contorno(conjunto de pontos [x, y])) no dicionário
        for j in dict_filling_points[i]: #para cada ponto[x, y] no contorno:

            j = list(np.append(j,0)) # a lista só contém os valores de x e y, essa linha faz o append de um terceiro valor para representar o eixo z, esse valor sempre é 0
            if i != i_atual: #se mudou de Contorno{numero do contorno} para Contorno{numero do contorno+1}
                Prototipo_lista_preenchimentos.append(list(np.add(j,[0,0,60]))) #acrescenta movimento em Z no inicio do contorno para não rabiscar entre contornos
                i_atual = i
            Prototipo_lista_preenchimentos.append(j) #acrescenta o ponto [x,y,z] na lista
        Prototipo_lista_preenchimentos.append(list(np.add(Prototipo_lista_preenchimentos[-1],[0,0,60]))) #acrescenta movimento em Z no fim do contorno para não rabiscar entre contornos
    
    return imagem_binarizada,Prototipo_lista_preenchimentos
