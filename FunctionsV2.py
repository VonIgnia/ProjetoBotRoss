#PT_BR bibliotecas para processamento de imagem
#US_EN libraries for image processing
import cv2
import matplotlib.pyplot as plt
import numpy as np
from pykuwahara import kuwahara
from math import *

#PT_BR arquivo criado pelos desenvolvedores para armazenar as funções e deixar o código mais limpo
#US_EN developer created file in order to store the functions and make a cleaner code here
import Functions

#PT_BR bibliotecas para comunicação com o UR5
#US_EN libraries for UR5 communication
import socket
import time
import threading

from tkinter import filedialog

###Code begins

def select_image():
    filepath = filedialog.askopenfilename(title="Select an Image", filetypes=[("Image files", "*.png;*.jpg;*.jpeg")])
    return filepath

def resize_keeping_aspect_ratio(img_in,tamanho_folha):
    current_height, current_width = img_in.shape[:2]
    width = tamanho_folha[0]
    height = tamanho_folha[1]

    if height>width:
        width = 0
    
    if width>height:
        height = 0

    if width == 0:
        # Calculate the ratio based on the desired height
        ratio = height / float(current_height)
        
    else:
        # Calculate the ratio based on the desired width
        ratio = width / float(current_width)

    new_width = int(current_width * ratio)
    new_height = int(current_height * ratio)
    resized_img_in = cv2.resize(img_in, (new_width, new_height))
    
    #imagem que o robô irá desenhar:
    #img_v = cv2.flip(hsv_img_in_norm, 0) # flip the image by vertically
    #img_h = cv2.flip(hsv_img_in_norm, 1) # flip the image by horizontally
    #img_vh = cv2.flip(resized_img_in,-1) # flip the image in both axis
    img_out = resized_img_in
    #img_out = cv2.flip(resized_img_in, 1)
    #img_out = cv2.flip(img_out,-1)

    return img_out
    return resized_image

# SimplifyImageColors "scans" an image and convert every pixel color to the closest color in HSV from the availabel colors list
#available_colors_list is a list composed of a number of lists with 3 elements(Hue, Saturation, Value)
#available_colors_list must be give in the format (H[0-360], S([0-100], V[0-100])
#kH, kS and kV are weight factor attributed to importance of Hue, Saturation nd Value respectively
def Simplify_Image_Colors(img_in, available_colors_list, kH = 1, kS = 1 , kV = 1):
    hsv_resized_image = cv2.cvtColor(img_in, cv2.COLOR_BGR2HSV)
    [H,S,V] = cv2.split(hsv_resized_image)
    (height,width) = H.shape

    #normalize HSV parameters to match opencv documentation
    #converts "normal" parameters of HSV to opencv2 parameters of HSV (check opencv documentation)
    #For HSV, hue range is [0,179], saturation range is [0,255], and value range is [0,255]
    for color in available_colors_list:
        color[0] = int(np.clip((color[0])/2,0,255))
        color[1] = int(np.clip((color[1]*255)/100,0,255))
        color[2] = int(np.clip((color[2]*255)/100,0,255))

    H_out = np.zeros((height,width), dtype = "uint8")
    S_out = np.zeros((height,width), dtype = "uint8")
    V_out = np.zeros((height,width), dtype = "uint8")

    for i in range(height-1):
        for j in range(width-1):
            #icv refers to image color vector and corresponds to the HSV vector from the pixel [i,j]
            icv = [H[i,j],S[i,j],V[i,j]]
            euclidian_distance_list = []
            #avc refers to available color vector and corresponds to the HSV vector from the availabel colors list
            
            #calculate the distance beetwen the availabel color and the pixel color for every available color
            for avc in available_colors_list:
                dist_euclidiana = sqrt(((avc[0]-icv[0])**2)*kH + ((avc[1]-icv[1])**2)*kS + ((avc[2]-icv[2])**2)*kV)
                euclidian_distance_list.append(dist_euclidiana)
            
            #the minimum distance indicates what availabel color is the closest to the pixel color 
            min_dist_index = np.argmin(euclidian_distance_list)
            H_out[i,j] = available_colors_list[min_dist_index][0]
            S_out[i,j] = available_colors_list[min_dist_index][1]
            V_out[i,j] = available_colors_list[min_dist_index][2]

    hsv_img_out = cv2.merge((H_out,S_out,V_out))

    return hsv_img_out

#Split colors input is generated by SimplifyImageColors
#It creates an array of binary images, one for each available color
def Split_Colors(img_in, available_colors_list):
    (height,width) = (img_in.shape[0], img_in.shape[1])
    
    img_out = np.zeros((height,width), dtype="uint8")
    img_out = cv2.cvtColor(img_out,cv2.COLOR_GRAY2BGR)

    dict_splitted_color_images = {}
    for color in available_colors_list:
        for i in range(height-1):
            for j in range(width-1):
                if np.all(img_in[i,j] == color):
                    img_out[i,j] = color
                else:
                    img_out[i,j] = [0,0,0]
        img_out = cv2.cvtColor(img_out, cv2.COLOR_HSV2BGR)
        #print("{},".format(color))
        #cv2.imshow(str(color), img_out)
        #cv2.waitKey(0)
        dict_splitted_color_images[str(color)] = img_out
    return dict_splitted_color_images

def Generate_fillings(img_in,color):
    height, width = img_in.shape[:2]
    line_spacing = 2

    # create a frame
    line_image = np.zeros((height, width), dtype=np.uint8)

    # Draw horizontal lines on the binary image
    for y in range(0, height, line_spacing):
        for x in range(0, width):
            line_image[y,x] = img_in[y,x]

    # Find contours of the image
    contours, hierarchy = cv2.findContours(line_image, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)

    #search for the intersection of lines and the inside region of a contour
    i=0
    dict_filling_points = {}
    for contour in contours:
        i+=1
        filling_points = []
        
        x,y,w,h = cv2.boundingRect(contour)
        filling_points.append([x,y])
        filling_points.append([x+w,y])
        
        cv2.line(line_image, (x,y), (x+w,y), (255,255,255), 1) 

        dict_filling_points["Preenchimento{}".format(color)] = filling_points

    Prototipo_lista_preenchimentos = []

    i_atual = 0 #flag para checar se mudou de Contorno{numero do contorno} para Contorno{numero do contorno+1}
    for i in dict_filling_points: #para cada elemento(contorno(conjunto de pontos [x, y])) no dicionário
        for j in dict_filling_points[i]: #para cada ponto[x, y] no contorno:

            j = list(np.append(j,0)) # a lista j só contém os valores de x e y, essa linha faz o append de um terceiro valor para representar o eixo z, esse valor sempre é 0
            if i != i_atual: #se mudou de Contorno{numero do contorno} para Contorno{numero do contorno+1}
                Prototipo_lista_preenchimentos.append(list(np.add(j,[0,0,60]))) #acrescenta movimento em Z no inicio do contorno para não rabiscar entre contornos
                i_atual = i
            Prototipo_lista_preenchimentos.append(j) #acrescenta o ponto [x,y,z] na lista
        Prototipo_lista_preenchimentos.append(list(np.add(Prototipo_lista_preenchimentos[-1],[0,0,60]))) #acrescenta movimento em Z no fim do contorno para não rabiscar entre contornos
    
    #return imagem_binarizada,Prototipo_lista_preenchimentos
    #i atual representa o numero final de contornos, por isso está aparecendo Preenchimento994 ou Preenchimento1037 (essas coisas)
    
    #cv2.imshow("{}".format(i_atual), line_image)
    
    #cv2.waitKey(0)
    return Prototipo_lista_preenchimentos

# Function to handle receiving data from UR5
def receive_data_from_ur5(HOST, PORT_RECEIVE):
    receive_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    receive_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    receive_socket.bind((HOST, PORT_RECEIVE))
    receive_socket.listen(5)
    c, addr = receive_socket.accept()
    if (addr[0] != ''):
        reciever_connected = True
        print(f"Listening for UR5 data on {HOST}:{PORT_RECEIVE}")
    return reciever_connected

# Function to handle sending instructions to UR5
def send_instructions_to_ur5(HOST, PORT_SEND):
    send_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    send_socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    send_socket.bind((HOST, PORT_SEND))
    send_socket.listen(5)
    c, addr = send_socket.accept()
    if (addr[0] != ''):
        sender_connected = True
        print(f"Connected to UR5 for sending instructions on {HOST}:{PORT_SEND}")
    return sender_connected

